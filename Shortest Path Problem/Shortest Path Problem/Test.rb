require 'pqueue'  # Підключаємо бібліотеку для роботи з пріоритетною чергою
require 'benchmark'  # Підключаємо бібліотеку для вимірювання часу виконання

# Функція знаходження найкоротшого шляху за методом SSSP (алгоритм Дейкстри)
def dijkstra(graph, start, goal)
  # Ініціалізація відстаней для кожної вершини (за замовчуванням - нескінченність)
  distances = Hash.new(Float::INFINITY)  # Створюємо хеш для збереження відстаней до кожної вершини
  distances[start] = 0  # Встановлюємо відстань до початкової вершини як 0

  # Пріоритетна черга для обробки вершин за мінімальною відстанню
  queue = PQueue.new { |a, b| distances[a] < distances[b] }  # Створюємо пріоритетну чергу для обробки вершин
  queue.push(start)  # Додаємо початкову вершину до черги

  # Хеш для відслідковування попередників (щоб побудувати найкоротший шлях)
  previous = {}  # Створюємо хеш для збереження попередників кожної вершини

  until queue.empty?  # Поки черга не порожня
    current = queue.pop  # Витягуємо вершину з найменшою відстанню з черги
    current_distance = distances[current]  # Зберігаємо поточну відстань до оброблюваної вершини

    # Якщо ми досягли цільової вершини, зупиняємо обчислення
    break if current == goal  # Перевіряємо, чи є поточна вершина цільовою

    # Обробка сусідніх вершин
    graph[current].each do |neighbor, weight|  # Перебираємо всіх сусідів поточної вершини
      distance = current_distance + weight  # Обчислюємо нову відстань до сусідньої вершини
      # Якщо знайдено коротший шлях до сусідньої вершини
      if distance < distances[neighbor]  # Якщо нова відстань коротша за поточну
        distances[neighbor] = distance  # Оновлюємо найкоротшу відстань до сусідньої вершини
        queue.push(neighbor)  # Додаємо сусідню вершину до черги
        previous[neighbor] = current  # Оновлюємо попередника для побудови шляху
      end
    end
  end

  # Відновлення найкоротшого шляху
  path = []  # Масив для збереження найкоротшого шляху
  current = goal  # Починаємо відновлення шляху з цільової вершини
  while current  # Поки існує поточна вершина
    path.unshift(current)  # Додаємо поточну вершину на початок шляху
    current = previous[current]  # Переходимо до попередньої вершини
  end

  # Якщо початкова вершина не входить в шлях, значить шляху не існує
  return nil if path.first != start  # Якщо перша вершина не є початковою, повертаємо nil

  { path: path, distance: distances[goal] }  # Повертаємо хеш із найкоротшим шляхом та його вартістю
end

# Приклад графу (зважений, орієнтований або неорієнтований)
graph = {
  'A' => { 'B' => 1, 'C' => 4 },  # Вершина A з'єднана з B (вага 1) і C (вага 4)
  'B' => { 'A' => 1, 'D' => 2, 'E' => 5 },  # Вершина B з'єднана з A, D і E
  'C' => { 'A' => 4, 'F' => 3 },  # Вершина C з'єднана з A і F
  'D' => { 'B' => 2 },  # Вершина D з'єднана з B
  'E' => { 'B' => 5, 'F' => 1 },  # Вершина E з'єднана з B і F
  'F' => { 'C' => 3, 'E' => 1 }  # Вершина F з'єднана з C і E
}

# Пошук найкоротшого шляху між двома вершинами
start = 'A'  # Початкова вершина
goal = 'F'  # Цільова вершина

# Додавання бенчмарків для вимірювання часу виконання алгоритму
benchmark_result = Benchmark.measure do
  result = dijkstra(graph, start, goal)  # Викликаємо функцію для пошуку найкоротшого шляху

  if result  # Якщо результат знайдено
    puts "Найкоротший шлях: #{result[:path].join(' -> ')}"  # Виводимо найкоротший шлях
    puts "Загальна вартість шляху: #{result[:distance]}"  # Виводимо загальну вартість шляху
  else
    puts "Шлях між #{start} і #{goal} не знайдено."  # Повідомляємо, якщо шлях не знайдено
  end
end

puts "Час виконання алгоритму: #{benchmark_result.real} секунд"  # Виводимо час виконання алгоритму